import io
import os
import re
import json
import time
import boto3
import base64
import string
import random
import requests
import streamlit as st

from requests import request
from sigv4 import SigV4HttpRequester

def session_generator():
    # Generate random characters and digits
    digits = ''.join(random.choice(string.digits) for _ in range(4))  # Generating 4 random digits
    chars = ''.join(random.choice(string.ascii_lowercase) for _ in range(3))  # Generating 3 random characters
    
    # Construct the pattern (1a23b-4c)
    pattern = f"{digits[0]}{chars[0]}{digits[1:3]}{chars[1]}-{digits[3]}{chars[2]}"
    print("Session ID: " + str(pattern))

    return pattern

# Bedrock Variable
# agentId = os.environ['BEDROCK_AGENT_ID']
# agentAliasId = os.environ['BEDROCK_AGENT_ALIAS_ID']
# knowledgeBaseId = os.environ['BEDROCK_KB_ID']
# dataSourceId = os.environ['BEDROCK_DS_ID']

# # Other Resource Variables
# knowledge_base_s3_bucket = os.environ['KB_BUCKET_NAME']

agentId = "NA7C0REXUS"
agentAliasId = "NSMQMZIGCO"
knowledgeBaseId = "0P4LJSHMMG"
dataSourceId = "OB8EQFTWLG"

# Other Resource Variables
knowledge_base_s3_bucket = "knowledgebase-bedrock-cop10"

# agents = bedrock-agent-runtime.us-east-1.amazonaws.com
# knowledgebases = bedrock-agent.us-east-1.amazonaws.com
kb_url = f'https://bedrock-agent.us-east-1.amazonaws.com/knowledgebases/{knowledgeBaseId}/datasources/{dataSourceId}/ingestionjobs/'

# AWS Session and Clients Instantiation
region_name="us-east-1"
session = boto3.Session(region_name)
agent_client = boto3.client('bedrock-agent-runtime')
# agent_client = boto3.client('bedrock-agent')
s3_client = boto3.client('s3',region_name=region_name,config=boto3.session.Config(signature_version='s3v4',))

# Streamlit CSS
custom_css = """
    <style>
        .text-with-bg {
        color: white;
            background-color: #27664e; /* Change this to your desired background color */
            padding: 10px;
            border-radius: 5px;
        }
    </style>
"""

# Streamlit App Layout
st.title('Tobacco Regulatory Assistant')
st.subheader('Regulations on Marketing, Sales, Advertisements..')
st.info("**DISCLAIMER:** This demo uses an Amazon Bedrock based Anthropic Claude foundation model and is not intended to collect any personally identifiable information (PII) from users. Please do not provide any PII when interacting with this demo. The content generated by this demo is for demo purposes only.")
idp_logo = "tobacco_regulations.png"
st.sidebar.image(idp_logo, width=300, output_format='PNG')
st.sidebar.markdown(custom_css, unsafe_allow_html=True)
st.sidebar.subheader('**About this Demo**')
st.sidebar.markdown('<p class="text-with-bg">The Tobacco Regulatory assistant uses Agents and Knowledge base for Amazon Bedrock to assist human regulatory analysts by providing summaries and answer to questions related to marketing, sales, advertisement, age verification related compliance rules and regulations. </p>', unsafe_allow_html=True)

# Helper Functions
def show_pdf(uploaded_file):
    if uploaded_file is not None:
        file_contents = uploaded_file.getvalue()

        # Convert the file content to base64
        base64_pdf = base64.b64encode(file_contents).decode('utf-8')
        
        # Display the PDF
        pdf_display = f'<iframe src="data:application/pdf;base64,{base64_pdf}" width="500" height="500" type="application/pdf"></iframe>'
        st.markdown(pdf_display, unsafe_allow_html=True)

# Invoke Agent
def bedrock_agent(query, sessionId):
    if query is not None:

        agent_query = {
            "inputText": query,   
            "enableTrace": True,
        }

        # send request
        print("Invoking Agent with query: " + query)
        agent_url = f'https://bedrock-agent-runtime.us-east-1.amazonaws.com/agents/{agentId}/agentAliases/{agentAliasId}/sessions/{sessionId}/text'
        requester = SigV4HttpRequester()
        response = requester.send_signed_request(
            url=agent_url,
            method='POST',
            service='bedrock',
            headers={
                'content-type': 'application/json', 
                'accept': 'application/json',
            },
            region='us-east-1',
            body=json.dumps(agent_query)
        )
        
        print(f"Raw Response: {response}")
        if response.status_code == 200:
            # Parse sig4_request Response
            response_string = ""
            for line in response.iter_content():
                try:
                    response_string += line.decode(encoding='utf-8')
                except:
                    continue
            print("response string original: " + str(response_string))
            split_response = response_string.split(":message-type")
            print("split_response: " + str(split_response))
            last_response = split_response[-1]
            try:
                encoded_last_response = last_response.split("\"")[3]
                print("encoded_last_response: " + str(encoded_last_response))
                if encoded_last_response == "citations":
                    # Find the start and end indices of the JSON content
                    start_index = last_response.find('{')
                    end_index = last_response.rfind('}')

                    # Extract the JSON content
                    json_content = last_response[start_index:end_index + 1]

                    try:
                        data = json.loads(json_content)
                        final_response = data['attribution']['citations'][0]['generatedResponsePart']['textResponsePart']['text']
                    except json.decoder.JSONDecodeError as e:
                        print(f"JSON decoding error: {e}")
                    except KeyError as e:
                        print(f"KeyError: {e}")
                else:
                    decoded = base64.b64decode(encoded_last_response)
                    final_response = decoded.decode('utf-8')
            except base64.binascii.Error as e:
                print(f"Base64 decoding error: {e}")
                final_response = last_response  # Or assign a default value

        print("Agent Response: " + final_response)
        return final_response

def update_knowledge_base(file_content, bucket_name, s3_file_name):
    print("Syncing Knowledge Base Data Source")

    try:
        # Wrap the bytes content in an in-memory file-like object
        file_obj = io.BytesIO(file_content)

        s3_client.upload_fileobj(file_obj, bucket_name, s3_file_name)
        st.success(f"File uploaded successfully to S3 bucket '{bucket_name}' as '{s3_file_name}'")
    except Exception as e:
        st.error(f"Error uploading file to S3: {e}")
    finally:
        file_obj.close()  # Close the file-like object after upload

    # Define HTTP request payload (StartIngestionJobRequestContent)
    description = "Programmatic update of Bedrock Knowledge Base Data Source"

    kb_update = {
        "description": description,   
    }

    # agent_client.start_ingestion_job(knowledgeBaseId=knowledgeBaseId, dataSourceId=dataSourceId, description=description)
    print("Starting Ingestion Job")
    requester = SigV4HttpRequester()
    response = requester.send_signed_request(
        url=kb_url,
        method='PUT',
        service='bedrock',
        headers={
            'content-type': 'application/json', 
            'accept': 'application/json',
        },
        region='us-east-1',
        body=json.dumps(kb_update)
    )    
    
    print("Finished Ingestion Job: " + str(response))
    return response

# def check_ingestion_job_status():
#     headers = {
#         "Content-type": "application/json",
#         # Add any necessary headers here
#     }

#     status = ""
#     while status != "complete":
#         try:
#             response = agent_client.list_ingestion_jobs(
#                 knowledgeBaseId=knowledgeBaseId,
#                 dataSourceId=dataSourceId,
#             )

#             if response.status_code == 200:
#                 job_status = response.json()["ingestionJobSummaries"][0]["status"]
#                 if job_status == "complete":
#                     st.write(f"Ingestion Job Status: {job_status}")
#                     break
#                 else:
#                     st.write(f"Polling... Current Job Status: {job_status}")
#             else:
#                 st.write(f"Error: {response.status_code} - {response.text}")
#         except Exception as e:
#             st.write(f"An error occurred: {e}")

#         time.sleep(5)  # Poll every 5 seconds (adjust as needed)

def main():
    # Main Execution Block
    if not "valid_inputs_received" in st.session_state:
        st.session_state["valid_inputs_received"] = False

    # --- Agent Q&A ---
    st.subheader('Input for the assistant')
    query = st.text_input("User Input", value="", placeholder="What can the agent help you with?", label_visibility="visible")
    agent_response = None  # Initialize agent_response variable
    
    if st.session_state.get("previous_query") != query and query != "":
        if "session_id" not in st.session_state:
            st.session_state["session_id"] = session_generator()

        sessionId = st.session_state["session_id"]

        agent_response = bedrock_agent(query, sessionId)
        st.session_state["previous_query"] = query  # Update previous_query if query changes

    if agent_response is not None:
        st.write("Agent's Response:", agent_response)


    # Example Prompts Section
    st.write("## Test Knowledge Base Prompts")

    # Creating a list of prompts for the Knowledge Base section
    knowledge_base_prompts = [
    {"Prompt": "What are the restrictions on advertising, promotion, and sponsorship of tobacco products?"},
    {"Prompt": "Does current legislation provide guidelines on the manufacturing standards for tobacco products?"},
    {"Prompt": "Are there specific prohibitions on the sale of tobacco products near educational establishments?"},
    {"Prompt": "What are the specific requirements for the moisture content in tobacco used in the manufacture of cigarettes?"},
    {"Prompt": "Are there specific limits for pesticide residues in tobacco?"},
    {"Prompt": "What are the labelling requirements for cigarette packages?"},
    {"Prompt": "What is the deadline for manufacturers and importers of tobacco products to submit annual reports to the competent authority?"},
    {"Prompt": "What are the obligations for manufacturers and importers regarding the investigation and reporting on additives?"},
    {"Prompt": "What determines whether a novel tobacco product is a tobacco product for smoking or a smokeless tobacco product?"},
    {"Prompt": "What should be the moisture content of tobacco?"},
    {"Prompt": "What is the allowed nicotine content in cigarettes?"}


    ]

    # Displaying the Knowledge Base prompts as a table
    st.table(knowledge_base_prompts)


    # --- Knowledge Base Update ---
    # st.subheader("Knowledge Base for Amazon Bedrock - File Upload")
    # uploaded_file = st.file_uploader("Upload Document", type=["csv", "doc", "docx", "htm", "html", "md", "pdf", "txt", "xls", "xlsx"])

    # if uploaded_file is not None:
    #     with st.expander("Uploaded File üìÅ"):
    #         show_pdf(uploaded_file)

    #     file_details = {"FileName": uploaded_file.name, "FileType": uploaded_file.type}
    #     file_name = "knowledge-base-assets/" + file_details["FileName"]

    #     # Display the contents of the file (for text-based formats like txt, pdf, docx)
    #     if uploaded_file.type == "text/plain":
    #         text = uploaded_file.read()
    #         st.write("Content:")
    #         st.write(text.decode("utf-8"))  # Decode bytes to string for display

    #     print("Uploading document to Amazon S3")
    #     file_contents = uploaded_file.getvalue()
    #     update_knowledge_base(file_contents, knowledge_base_s3_bucket, file_name)
    #     check_ingestion_job_status()

# Call the main function to run the app
if __name__ == "__main__":
    main()
